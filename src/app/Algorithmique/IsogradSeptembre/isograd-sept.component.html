<section>
    <div class="sommaire">
        <ul>
            <li>
                <a (click)="goto(' #introduction')">Introduction</a>
            </li>
            <li>
                <a (click)="goto(' #principe')">Principe du concours</a>
            </li>
            <li>
                <a (click)="goto(' #exo1')"> Problème 1 </a>
                <ul>
                    <li>
                        <a (click)="goto(' #exo1Statement')"> Enoncé </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo1Solution')"> Solution </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo1Impl')"> Implémentation </a>
                    </li>
                </ul>
            </li>
            <li>
                <a (click)="goto(' #exo2')"> Problème 2 </a>
                <ul>
                    <li>
                        <a (click)="goto(' #exo2Statement')"> Enoncé </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo2Solution')"> Solution </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo2Impl')"> Implémentation </a>
                    </li>
                </ul>
            </li>
            <li>
                <a (click)="goto(' #exo3')"> Problème 3 </a>
                <ul>
                    <li>
                        <a (click)="goto(' #exo3Statement')"> Enoncé </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo3SolutionNaive')"> Solution concours </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo3Impl')"> Implémentation </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo3VraieSolution')"> Solution complète </a>
                    </li>
                </ul>
            </li>
            <li>
                <a (click)="goto(' #exo4')"> Problème 4 </a>
                <ul>
                    <li>
                        <a (click)="goto(' #exo4Statement')"> Enoncé </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo4Solution')"> Solution </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo4Impl')"> Implémentation </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo4Dyn')"> Solution dynamique </a>
                    </li>
                </ul>
            </li>
            <li>
                <a (click)="goto(' #exo5')"> Problème 5 </a>
                <ul>
                    <li>
                        <a (click)="goto(' #exo5Statement')"> Enoncé </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo5Solution')"> Solution </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo5Impl')"> Implémentation </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo5SolutionMemo')"> Solution avec mémo </a>
                    </li>
                    <li>
                        <a (click)="goto(' #exo5ImplMemo')"> Implémentation avec mémo </a>
                    </li>
                </ul>
            </li>

        </ul>
    </div>
    <div class="wrapperArticle">
        <div class="article">
            <h1 class="post-title ">
                Solutions et retour sur le concours Isograd (septembre 2020)
            </h1>
            <div class="blockArticle">
                <h3 id="introduction">Hello tout le monde!</h3>
            </div>
            <div>

                Fin septembre s'est déroulé un concours algorithmique organisé par Isograd, sur le thème de la sécurité
                informatique. J'ai pu terminer premier malgré un duel très serré, après avoir été devancé sur les quatre
                premiers exercices par le redoutable Nagrarok.<br />
                <br />
                Vous pouvez retrouver les différents problèmes ainsi que le classement ici: <a
                    href="https://www.isograd.com/FR/solutionconcours.php?contest_id=65&que_str_id=&reg_typ_id=2">Resultats
                    et problèmes</a>. <br />
                Si ça vous intéresse de discuter des solutions, ou de l'algorithmique et de
                la
                sécurité informatique, n'hésitez pas à suivre <a href="https://twitter.com/h25io">@h25io</a> sur twitter
                et à rejoindre leur discord.<br />
                <br />

                Dans cet article, je vais tout d'abord présenter rapidement comment fonctionne ce concours, puis je vais
                passer sur chaque exercice, pour donner mon approche (ce que je regarde au niveau de l'énoncé, les
                réflexes à avoir), une
                explication de ma solution durant le concours, ainsi que d'autres variantes et douces rêveries du même
                thème.<br />
                <br />

                <h2 id="principe">Le concours</h2>
                Le principe du concours était le suivant:
                <ul>
                    <li>
                        5 problèmes de difficulté croissante à résoudre de manière séquentielle (pour passer au problème
                        N+1, il fallait d'abord résoudre entièrement le problème N)
                    </li>
                    <li>Chaque problème est doté:
                        <ul>
                            <li>
                                D'un énoncé donnant le contexte du problème, ainsi que le résultat attendu
                            </li>
                            <li>
                                D'une description des entrées et sorties (contraintes (ordre de grandeur des différentes
                                valeurs), type des données)
                            </li>
                            <li>
                                D'un ou plusieurs exemples (entrée(s) et sortie(s) attendue(s))
                            </li>
                        </ul>
                    </li>
                </ul><br />
                A partir de ces informations fournies, l'objectif est de coder un programme dans un langage
                informatique
                parmi la multitude proposée par la plateforme Isograd, qui va:
                <ul>
                    <li>Lire les entrées sur l'entrée standard (<code>cin</code> pour C++, <code>scanf</code> pour C,
                        <code>input()</code> pour
                        Python
                        par exemple)
                    </li>
                    <li>Renvoyer sur la sortie standard (<code>cout</code> pour C++, <code>printf</code> pour C,
                        <code>print</code> pour Python ...)
                        la
                        réponse correspondante aux entrées
                    </li>
                </ul><br />
                En exemple de problème, on pourrait avoir par exemple: "Lire 2 entiers et afficher la somme."<br />
                <br />
                Une solution en pseudocode donnerait<br />
                <br />
                <pre class="line-numbers language-python"><code >a = lireEntreeStandard()
b = lireEntreeStandard()
afficherSurSortieStandard(a+b)
</code></pre>
                <br />
                Bien sûr, cet exemple est très simple, et les problèmes proposés durant le concours sont d'un tout
                autre
                niveau.<br /><br />
                <h2 id="exo1">Problème 1:</h2>
                <br />
                <h3 id="exo1Statement"> Enoncé </h3>
                Pour le problème 1, on recevait sur l'entrée standard une liste d'identifiants de badges de sécurité.
                Ces identifiants étaient des chaînes de caractères de 8 chiffres ("00000000", "12345678" par
                exemple...), et l'objectif était de trouver le seul identifiant qui ne se terminait pas par les
                caractères
                "555".<br />
                <br />
                Par exemple avec l'entrée:<br />
                <pre class="line-numbers language-python"><code >4
00000555
12345678
42840555
55555555</code></pre>
                la sortie attendue est la suivante:<br />
                <pre class="line-numbers language-python"><code >12345678</code></pre><br />
                Ce problème était essentiellement pour se familiariser avec l'IDE web d'Isograd, et était donc
                relativement accessible même aux plus débutants.<br />
                <br />

                <h3 id="exo1Solution"> Solutions </h3>

                Deux types de solutions principales étaient possibles:
                <ul>
                    <li>Soit on itère manuellement sur la chaîne pour vérifier qu'au moins un des 3 derniers caractères
                        est bien
                        différent de '5'
                    </li>
                    <li>Soit on utilisait une fonction du langage choisi pour extraire le suffixe constitué des 3
                        derniers caractères, qu'on comparait avec la chaîne de caractères "555"</li>
                </ul>
                La seconde solution était plus rapide à implémenter, si vous connaissiez déjà la fonction vous
                permettant d'extraire le suffixe.<br />
                <br />
                Durant le concours, je n'avais pas vu que la taille des identifiants était constante (8 caractères).
                J'ai donc géré un cas spécial (le cas où la chaîne faisait moins de 3 caractères) pour éviter que
                l'extraction du suffixe ne pose problème (suivant la méthode utilisée, cela aurait pu extraire un
                suffixe
                depuis un indice négatif).<br />
                <br />
                <h3 id="exo1Impl">Implémentation</h3>

                <ul ngbNav #nav="ngbNav" class="nav-tabs" (navChange)="onNavChange($event)">
                    <li ngbNavItem>
                        <a ngbNavLink>Python</a>
                        <ng-template ngbNavContent>
                            <pre class="line-numbers language-python"><code >nombreIdentifiants = int(input())
for i in range(nombreIdentifiants):
    identifiant = input()
    if(identifiant[-3:] != "555"):
        print(identifiant)
</code></pre>
                        </ng-template>
                    </li>
                    <li ngbNavItem>
                        <a ngbNavLink>C++</a>
                        <ng-template ngbNavContent>
                            <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include "exercise.hpp"<br/>
<br/>
ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}}{{'}'}}<br/>
<br/>
void ContestExerciseImpl::main() {{'{'}}
    int nombreIdentifiants;
    cin&gt;&gt;nombreIdentifiants;
    for(int idx=0;idx&lt;nombreIdentifiants;idx++) {{'{'}}
        string identifiant;
        cin&gt;&gt;identifiant;
        if(identifiant.substr(identifiant.size()-3) != "555") {{'{'}}
            cout&lt;&lt;identifiant&lt;&lt;endl;
        {{'}'}}
    {{'}'}}
{{'}'}}
</code></pre>
                        </ng-template>
                    </li>
                    <li ngbNavItem>
                        <a ngbNavLink>Cacher</a>
                        <ng-template ngbNavContent>
                        </ng-template>
                    </li>
                </ul>
                <div [ngbNavOutlet]="nav"></div>
                <br />

                <h2 id="exo2">Problème 2:</h2>
                <br />
                <h3 id="exo2Statement">Enoncé:</h3>

                Le second problème était légèrement plus complexe:<br />
                On recevait encore une fois une liste d'identifiants, mais cette fois-ci, il fallait trouver
                l'identifiant le plus présent dans la liste (si plusieurs identifiants étaient représentés de manière
                maximale, n'importe lequel d'entre eux pouvait être renvoyé).<br />
                Par exemple, pour :
                <pre class="line-numbers language-python"><code >4
222
111
222
333</code></pre>
                La sortie attendue est:
                <pre class="line-numbers language-python"><code >222</code></pre>
                Mais si l'entrée était :
                <pre class="line-numbers language-python"><code >4
222
111
222
111</code></pre>
                On pouvait aussi bien renvoyer
                <pre class="line-numbers language-python"><code >222</code></pre>
                que
                <pre class="line-numbers language-python"><code >111</code></pre>
                <br />

                <h3 id="exo2Solution">Solutions</h3>
                L'énoncé ne contenait aucune contrainte sur la taille de la liste. Des immondices auraient donc
                peut-être pu passer les tests avec une complexité de <code>O(N^2)</code>.<br />
                <br />
                Néanmoins, la solution en complexité <code>O(N)</code> (ou <code>O(NlogN)</code> suivant la structure
                utilisée) était
                accessible.<br />
                Durant le concours, j'ai utilisé la structure map de la libraire standard C++.
                Cette structure permet de faire une association entre des clés et des valeurs.<br />
                <br />
                Grâce à ça, je peux garder en mémoire l'information du nombre de fois pour lequel chaque identifiant a
                été
                vu.<br />
                En reprenant le premier exemple ci-dessus, ma structure va se mettre à jour de la façon suivante, au
                cours des itérations:<br />
                <code>{{'{'}}{{'}'}} => {{'{'}}"222": 1{{'}'}} => {{'{'}}"111": 1, "222": 1{{'}'}} => {{'{'}}"111": 1, "222":
                2{{'}'}} => {{'{'}}"111": 1, "222": 2, "333": 1{{'}'}}</code><br />
                <br />
                Il suffit ensuite de parcourir cette structure pour trouver l'élément le plus représenté
                (<code>"222"</code>).<br />
                <br />
                En Python, une structure permet de faire ça de manière encore plus simplifiée. Il s'agit de la structure
                <code>Counter</code> qui est spécialisé dans ce rôle de compter le nombre d'occurences de différentes
                valeurs.<br />
                <h3 id="exo2Impl">Implémentation</h3>

                <ul ngbNav #nav2="ngbNav" class="nav-tabs" (navChange)="onNavChange($event)">
                    <li ngbNavItem>
                        <a ngbNavLink>Python</a>
                        <ng-template ngbNavContent>
                            <pre class="line-numbers language-python"><code >from collections import Counter<br/>
                                <br/>
nombreIdentifiants = int(input())
listeIdentifiants = [input() for idx in range(nombreIdentifiants)]
occurences = Counter(listeIdentifiants)
print(occurences.most_common(1)[0][0])
# most_common(N) retourne une liste de N tuples (clé,valeur) des éléments les plus présents
# on prend donc le premier tuple ([0]) de ce tableau ainsi que la clé ([0]) de ce tuple
</code></pre>
                        </ng-template>
                    </li>
                    <li ngbNavItem>
                        <a ngbNavLink>C++</a>
                        <ng-template ngbNavContent>
                            <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include &lt;map&gt;
#include "exercise.hpp"<br/>
<br/>
ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}}{{'}'}}<br/>
<br/>
void ContestExerciseImpl::main() {{'{'}}
    int nbIdentifiants;
    cin&gt;&gt;nbIdentifiants;

    map&lt;string,int&gt; occurences;
    pair&lt;int,string&gt; res = make_pair(0,"");
    for(int idx=0;idx&lt;nbIdentifiants;idx++) {{'{'}}
        string identifiant;
        cin&gt;&gt;identifiant;
        occurences[identifiant]++;
        res = max(res, make_pair(occurences[identifiant],identifiant));
    {{'}'}}
    cout&lt;&lt;res.second;
{{'}'}}</code></pre>
                        </ng-template>
                    </li>
                    <li ngbNavItem>
                        <a ngbNavLink>Cacher</a>
                        <ng-template ngbNavContent>
                        </ng-template>
                    </li>
                </ul>
                <div [ngbNavOutlet]="nav2"></div>




                <h2 id="exo3"> Exercice 3</h2>
                <br />
                <h3 id="exo3Statement"> Enoncé</h3>
                <br />
                Le troisième problème présentait un <b>ENORME</b> pic de difficulté par rapport aux deux premiers.
                Pour un grand nombre de compétiteurs (j'en fais partie), ce problème fut le plus compliqué des 5.<br />
                <br />
                Pour ce problème, on avait en entrée un <b>graphe dirigé</b> de serveurs reliés par des arcs.
                La spécificité d'un graphe dirigé étant que si l'on a un arc qui part d'un noeud A pour arriver à un
                autre noeud B, il n'existe pas forcément l'arc inverse permettant de partir de B pour arriver à A.<br />
                <br />
                Egalement, d'autres contraintes étaient appliquées sur ce graphe: un noeud ne peut avoir qu'un seul
                prédecesseur (en d'autres termes, s'il existe un arc <code>A=>B</code>, alors il n'existe pas d'autre
                noeud X tel
                qu'il existe un arc <code>X=>B</code>, puisque <code>B</code> ne peut avoir qu'un prédecesseur).<br />
                <br />

                L'objectif est de trouver le serveur à partir duquel on peut accéder au plus grand nombre de serveurs de
                manière directe ou indirecte en suivant les arcs dirigés. Si plusieurs serveurs sont valides, celui avec
                l'identifiant le plus petit doit être donné.<br /><br />
                Par exemple, si on a le graphe suivant:<br /><br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/graph.png" />
                </div>

                <br /><br />

                Alors, les noeuds 1 et 5 ont tous les deux accès à 4 serveurs, donc on renvoie le serveur 1 qui a un
                identifiant plus petit.
                <br /><br />


                <h3 id="exo3SolutionNaive"> Une première solution, pour un graphe sans cycle</h3>
                Dans un premier temps, on va partir de mon interprétation erronée durant le concours.
                Mais on verra que ma solution peut être adaptée très facilement pour remplir les conditions de
                l'énoncé.<br />
                <br />
                Ma vision erronée était la suivante:
                <ul>
                    <li>
                        Le graphe ne contient pas de cycle
                    </li>
                    <li>
                        Un noeud PEUT avoir plusieurs prédécesseurs.
                    </li>
                </ul>
                Jusqu'à maintenant, j'ai très peu parlé de méthodologie dans l'analyse de l'énoncé.
                Les deux premiers problèmes étant relativement faciles, les seuls conseils pouvant être appliqués
                seraient les suivants:
                <div class="proTip">
                    <fa-icon [icon]="['far', 'lightbulb']"></fa-icon>
                    <ul>
                        <li>
                            Maîtriser la syntaxe de base de son langage (boucle, interaction avec l'entrée / sortie
                            standard, conditions)
                        </li>
                        <li>
                            Connaître un peu la librairie standard du langage (<code>max</code>, <code>min</code>,
                            <code>sort</code> ...) et les structures de
                            données basiques (tableaux, listes, sets, map...)
                        </li>
                    </ul>
                </div><br />
                Ici par contre, le problème étant plus ardu, certains réflexes plus avancés permettent d'être plus
                efficaces dans la
                résolution:
                <div class="proTip">
                    <fa-icon [icon]="['far', 'lightbulb']"></fa-icon>
                    <ul>
                        <li>
                            En premier lieu, <b>bien regarder les contraintes</b>. Les contraintes nous donnent une idée
                            de la
                            complexité de la solution attendue, et/ou nous permet d'écarter d'autres solutions pour
                            lesquelles la complexité sera trop grande.<br />
                            Habituellement, on considère qu'à partir d'un ordre grandeur de <code>10^8</code> opérations
                            (cela
                            fluctue un
                            peu), on commence à s'inquiéter du fait que notre programme soit assez efficace pour passer
                            avec
                            les limites de temps.
                            <br /><br />
                        </li>
                        <li>
                            Si on a un algorithme qui fait beaucoup d'opérations, se poser des questions en terme de
                            <b>"nécessité"</b> et de <b>"redondance"</b>.
                            <br />
                            Calcule-t-on des informations inutiles, en partant par exemple de noeuds qui donneront
                            toujours
                            des résultats inutiles? Calcule-t-on plusieurs fois la même chose? Si oui, est-il possible
                            de
                            conserver les résultats pour les réutiliser?
                        </li>
                    </ul>
                </div>
                Je me limite à un nombre restreint de pistes de réflexion, qui on le verra ensemble, s'appliquent à ce
                problème.<br />
                <br />
                Pour les contraintes, <code>N</code> et <code>M &lt;= 50 000</code>. On peut donc déjà (même si certains
                compétiteurs ont eu une
                solution avec cette complexité qui marchait) ignorer toute solution qui serait de complexité
                <code>O(N^2)</code> ou
                <code>O(M^2)</code> (puisque <code>50000 ^ 2 > 10^9</code>).<br />
                <br />
                Par contre, <code>O(N)</code>, <code>O(M)</code>, <code>O(NlogN)</code> et bien d'autres, sont des
                complexités qui semblent
                adaptées au
                problème.<br />
                <br />
                Maintenant partons de l'idée naïve, pour exploiter le deuxième axe de réflexion:<br />
                <ul>
                    <li> On peut partir de chaque noeud</li>
                    <li> Faire des appels récursifs sur les noeuds fils, petit-fils etc...</li>
                    <li> Pour calculer le nombre de noeuds accessibles depuis le noeud initial</li>
                    <li> Il suffira de garder le noeud pour lequel on aura le plus grand nombre de noeuds accessibles
                    </li>
                </ul>
                Cette solution, parfaitement valide, nous pose néanmoins un souci en terme de complexité:<br />
                on va itérer sur chaque noeud, et à partir de chaque noeud on va explorer tous ses descendants.<br />
                On est donc en <code>O(N^2)</code>.<br />
                <br />
                Maintenant appliquons la méthode décrite plus haute:<br />
                <br />
                <ul>
                    <li> Nécessité: A-t-on <b>besoin</b> de partir de chaque noeud pour vérifier si ce noeud est le
                        noeud de la
                        réponse?</li>
                    <ul>
                        <li><b>Réponse: Non.</b> On peut prendre uniquement les noeuds racines sans prédécesseur</li>
                        <li>Si un noeud a un prédecesseur, son prédecesseur a forcément un nombre de noeuds accessibles
                            strictement supérieur (vu qu'on compte également le noeud duquel on part comme accessible)
                        </li>
                    </ul>
                    <li> Redondance: Doit-on <b>à chaque fois</b> parcourir tous les noeuds de manière récursive?</li>
                    <ul>
                        <li><b>Réponse: Non.</b></li>
                        <li>
                            Si l'on a déjà calculé le nombre de noeuds accessibles à partir d'un noeud, ce nombre ne
                            changera pas au fur et à mesure des appels récursifs.
                        </li>
                        <li>
                            Il suffit donc de stocker pour chaque noeud cette valeur après l'avoir calculée une première
                            fois.
                        </li>
                    </ul>
                </ul>
                Ma solution finale correspond donc simplement à la <b>solution naïve</b>, mais en partant uniquement des
                <b>noeuds
                    "racines"</b> (sans prédecesseurs), et en enregistrant pour chaque noeud le nombre de noeuds
                descendants
                accessibles.<br />
                <br />
                <h3 id="exo3Impl">Implémentation</h3>
                <br />
                <p>
                    <button type="button" class="btn btn-outline-primary" (click)="isCollapsed2 = !isCollapsed2"
                        [attr.aria-expanded]="!isCollapsed2" aria-controls="collapseExample">
                        Afficher / Réduire le code
                    </button>
                </p>
                <div id="collapseExample" [ngbCollapse]="isCollapsed2">
                    <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include "exercise.hpp"

ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}} {{'}'}}

map&lt;int,int&gt; memo;
int nombreDescendants(int serveur, vector&lt;vector&lt;int&gt; &gt; &listeAdjacence){{'{'}}
    // Si on a déjà calculé le nombre de noeuds accessibles depuis le serveur
    if(memo.find(serveur) != memo.end()) {{'{'}}
        // On renvoie directement ce nombre
        return memo[serveur];
    {{'}'}}
    // Sinon, on exécute les appels récursifs sur les noeuds enfants
    int resultat = 1;
    for(auto child: listeAdjacence[serveur]) {{'{'}}
        resultat += nombreDescendants(child, listeAdjacence);
    {{'}'}}
    // On enregistre le résultat
    memo[serveur] = resultat;
    return resultat;
{{'}'}}

void ContestExerciseImpl::main() {{'{'}}
    int nbNodes, nbArcs;
    cin&gt;&gt;nbNodes&gt;&gt;nbArcs;

    vector&lt;vector&lt;int&gt; &gt; listeAdjacence(nbNodes);
    set&lt;int&gt; racines;

    for(int c=0;c&lt;nbNodes;c++) racines.insert(c);

    for(int c=0;c&lt;nbArcs;c++) {{'{'}}
        int from, to;
        cin&gt;&gt;from&gt;&gt;to;
        from--;to--;
        racines.erase(to);
        listeAdjacence[from].push_back(to);
    {{'}'}}

    pair&lt;int,int&gt; resultat = make_pair(-1,-1);
    for(auto serveur: racines) {{'{'}}
        int taille = nombreDescendants(serveur, listeAdjacence);
        resultat = max(resultat, make_pair(taille, -serveur));
    {{'}'}}

    cout&lt;&lt;-resultat.second+1;
{{'}'}}
               </code></pre>
                </div>

                <br />
                <h3 id="exo3VraieSolution"> Vraie solution (gestion des cycles)</h3>
                Maintenant si on revient à la vraie version de l'énoncé, le fait qu'un noeud ne pouvait avoir qu'un
                seul
                prédecesseur rend l'utilisation du stockage des valeurs inutile:<br />
                <br />
                si on part uniquement des noeuds racines on ne passera JAMAIS plusieurs fois par un même
                noeud.<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/MemoUseless.png" />
                </div>
                <br />

                Le second point est qu'il peut y avoir des cycles. Or dans le cas d'un cycle parfait (<code>1 => 2 => 3 =>
                4
                => 1</code> par exemple),il n'existe pas de noeud sans prédécesseur, même si on respecte la contrainte
                de
                graphe
                dirigé, avec des noeuds n'ayant pas plus d'un prédécesseur.<br />
                <br />
                Dans ce cas on a donc aucun parcours réalisé avec l'algorithme plus haut.<br />
                <br />
                Pour corriger ça, il suffit de faire une première passe classique (en partant des noeuds racines
                tant
                qu'on en a), et pour les cycles de partir de l'identifiant le plus faible de chaque cycle.<br />
                <br />
                Vu qu'un noeud ne peut avoir qu'un prédécesseur, on ne peut pas avoir de parties du graphe contenant
                à
                la fois au moins un noeud racine et un cycle.<br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/CycleRoot.png" />
                </div>
                <br />
                Pour la gestion du cycle, il suffit de faire un bête parcours pour en connaître la taille. Tous les
                noeuds de ce cycle ont le même nombre de descendants directs/indirects.<br />
                <br />
                Comme on traite les identifiants de manière croissante, pour chaque cycle, le seul noeud qui peut
                correspondre à la réponse sera le noeud à partir duquel on fait le parcours.<br />
                <br />

                <h2 id="exo4"> Exercice 4 </h2>
                <br />
                <h3 id="exo4Statement"> Enoncé </h3>
                <br />
                J'ai trouvé le quatrième problème plutôt original par rapport à ce que propose habituellement
                Isograd.
                Celui-ci a été trouvé "pénible à implémenter" par plusieurs compétiteurs, mais il existait beaucoup
                d'implémentations différentes, et celle que j'ai choisie n'était pas si laide que ça.<br />
                <br />
                En entrée on recevait une liste de chaîne de caractères, qui formaient une grille 2D de pixels avec
                différentes couleurs (dénotés par un type de caractère différent (<code>'#'</code>,<code> '.'</code>,
                <code>'!'</code> etc...)).<br />
                <br />
                A partir de cette grille, il fallait retrouver toutes les "formes continues" qui formaient des
                rectangles de dimension 2x4 ou 4x2, une forme étant constituée de tous les pixels de même couleur
                connexes.
                Si par exemple un rectangle 2x4 d'une couleur donnée avait un pixel voisin de la même couleur, ce
                pixel
                fait également partie de la forme et invalide la présence du rectangle 2x4.<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/rectangles.png" />

                </div>
                <br />

                <h3 id="exo4Solution"> Solutions </h3>
                Si on utilise la méthode d'analyse de complexité comme pour l'exercice précédent, on se rend compte
                que
                l'on a bien plus de marge de manoeuvre, vu que <code>N</code> et <code>M &lt;= 100</code>.
                <code>O(N^2*M^2)</code> par exemple resterait une complexité à priori envisageable, à partir du moment
                où le code
                est
                bien optimisé.<br />
                <br />
                Néanmoins, il serait presque plus dur de trouver un algorithme avec une si grosse complexité qu'un
                algorithme plus efficace.<br />
                <br />
                On va ajouter une réflexion à avoir à notre éventail de techniques:
                <div class="proTip">
                    <fa-icon [icon]="['far', 'lightbulb']"></fa-icon>
                    <ul>
                        <li>
                            Si pleins de solutions semblent s'offrir à vous, toutes de complexités acceptables:
                        </li>
                        <ul>
                            <li>
                                Choisissez le meilleur compromis entre intuition, facilité et rapidité d'implémentation
                            </li>
                        </ul>
                    </ul>
                </div>
                Je vais évoquer 3 types de solutions générales pour ce problème:<br />
                <br />
                La première consistait à partir de chaque case de la grille, et, en considérant que cette case est
                en
                haut à gauche du rectangle, de vérifier que les autres pixels voisins du rectangles ont une couleur
                différente, et que les pixels du rectangle ont bien la même couleur que la case de départ.<br />
                <br />
                C'est une variante de cette solution que beaucoup ont implémenté. Personnellement, je trouve cette
                solution assez pénible, et sûrement la raison pour laquelle beaucoup de codeurs ont trouvé
                l'implémentation chronophage.<br />
                <br />
                La complexité est de l'ordre de <code>N*M*Constante</code>, avec la Constante liée au nombre de pixels
                qui sont
                vérifiés pour chaque case de départ (normalement de l'ordre de <code>2*(tailleRectangle+tailleContour) =
                2*(8+12) = 40</code>).<br />
                <br />
                C'est la solution la plus naïve, simple intuitivement, qui passe les limites de temps, mais pas la
                plus
                simple à coder.<br />
                <br />
                Ma solution est, d'avis personnel, le meilleur compromis (mais c'est débattable):
                <ul>
                    <li>Relativement intuitive</li>
                    <li>Relativement simple à coder</li>
                </ul>
                De la même manière que la première solution, je parcours la grille séquentiellement, et à chaque
                case
                "non vide", je réalise un parcours (floodfill) pour extraire la forme continue dans un vector.
                Les coordonnées stockées sont translatées par rapport à la case de départ (exemple, si on part de
                <code>(2,2)</code>
                et qu'on a la forme <code>[(2,2),(2,3),(3,3)]</code> on aura donc
                <code>[(0,0),(0,1),(1,1)]</code>).<br />
                <br />
                Ensuite, je compare cette forme avec le pattern des deux autres rectangles, que j'aurais initialisé
                avec
                deux boucles imbriquées.<br />
                <br />
                Si les deux formes ont des tailles différentes, on sait déjà qu'il n'y a pas correspondance.
                Sinon je compare les deux formes pour lesquelles j'aurais au préalable trié les coordonnées. Je
                n'aurai
                donc qu'à comparer les coordonnées une par une.<br />
                <br />
                La complexité est <code>O(N*M*log(tailleRectangle))</code> (étant donné que je ne visite une case qu'une
                fois, et
                que
                pour chaque forme récupérée de taille 8, je la trie pour la comparer aux patterns). <br />
                <br />
                <h3 id="exo4Impl"> Implémentation</h3>
                <br />
                <p>
                    <button type="button" class="btn btn-outline-primary" (click)="isCollapsed = !isCollapsed"
                        [attr.aria-expanded]="!isCollapsed" aria-controls="collapseExample">
                        Afficher / Réduire le code
                    </button>
                </p>
                <div id="collapseExample" [ngbCollapse]="isCollapsed">
                    <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include "exercise.hpp"

ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}}{{'}'}}

void ContestExerciseImpl::main() {{'{'}}
    int hauteur, largeur;
    cin&gt;&gt;hauteur&gt;&gt;largeur;
    vector&lt;string&gt; grille(hauteur);

    const char VIDE = ' ';

    for(int c=0;c&lt;hauteur;c++) cin&gt;&gt;grille[c];

// Pour calculer les coordonnées voisines
    int dx[4]={{'{'}}0,0,1,-1{{'}'}};
    int dy[4]={{'{'}}1,-1,0,0{{'}'}};

    // Nos deux patterns de rectangles (4x2 et 2x4)
    vector&lt;vector&lt;pair&lt;int,int&gt; &gt; &gt; patterns(2);
    for(int x=0;x&lt;4;x++) for(int y=0;y&lt;2;y++) patterns[0].push_back(make_pair(x,y));
    for(int x=0;x&lt;2;x++) for(int y=0;y&lt;4;y++) patterns[1].push_back(make_pair(x,y));

    sort(patterns[0].begin(),patterns[0].end());
    sort(patterns[1].begin(),patterns[1].end());


    vector&lt;pair&lt;int,int&gt; &gt; resultat;

    for(int x = 0; x &lt; hauteur; x++) {{'{'}}
        for(int y = 0; y &lt; largeur; y++) {{'{'}}
            // Si on est pas sur une case vide
            if(grille[x][y] != VIDE){{'{'}}

                vector&lt;pair&lt;int,int&gt; &gt; parcours(1,make_pair(x,y));
                vector&lt;pair&lt;int,int&gt; &gt; forme(1,make_pair(0,0));

                // La couleur de notre forme
                // x,y étant le sommet en haut à gauche de la forme
                char couleurForme = grille[x][y];
                grille[x][y] = VIDE;

                // Algorithme de parcours classique
                while(parcours.size() != 0) {{'{'}}
                    int currentX = parcours.back().first;
                    int currentY = parcours.back().second;

                    parcours.pop_back();

                    for(int d=0;d&lt;4;d++) {{'{'}}
                        int newX = dx[d] + currentX;
                        int newY = dy[d] + currentY;

                        // On vérifie qu'on reste dans la grille, et qu'on ne traite que les pixels ayant la bonne couleur
                        if(newX &gt;= 0 && newY &gt;= 0 && newX &lt; hauteur && newY &lt; largeur && grille[newX][newY] == couleurForme) {{'{'}}
                            forme.push_back(make_pair(newX - x, newY - y));
                            parcours.push_back(make_pair(newX, newY));
                            grille[newX][newY] = VIDE;
                        {{'}'}}
                    {{'}'}}
                {{'}'}}

                // Si l'on a un nombre de pixels égal au nombre de pixels d'un rectangle 2x4 ou 4x2
                if(forme.size() == 8){{'{'}}
                    sort(forme.begin(),forme.end());

                    // On compare les coordonnées
                    for(int p = 0; p &lt; 2; p++) {{'{'}}
                        bool correspond = true;
                        for(int i = 0; i &lt; forme.size(); i++) {{'{'}}
                            if(forme[i].first != patterns[p][i].first || forme[i].second != patterns[p][i].second) {{'{'}}
                                correspond = false;
                                break;
                            {{'}'}}
                        {{'}'}}
                        // Si ça match, on ajoute à notre réponse
                        if(correspond) {{'{'}}
                            resultat.push_back(make_pair(x,y));
                            // Si le premier pattern correspond, on peut gagner un peu d'instructions
                            // en évitant de comparer avec le second pattern
                            break;
                        {{'}'}}
                    {{'}'}}
                {{'}'}}
            {{'}'}}
        {{'}'}}
    {{'}'}}

    // On affiche le nombre de rectangles trouvés
    cout&lt;&lt;resultat.size()&lt;&lt;endl;
    for(auto coordonnee: resultat) {{'{'}}
        // On ajoute 1 vu qu'on faisait du 0-index, mais que la solution attendue est en 1-index
        cout&lt;&lt;coordonnee.first+1&lt;&lt;" "&lt;&lt;coordonnee.second+1&lt;&lt;"\n";
    {{'}'}}
{{'}'}}
               </code></pre>
                </div>

                <br />
                <br />
                <h3 id="exo4Dyn"> Solution à base de programmation dynamique et somme de préfixes</h3>
                Une dernière solution, inspirée de la solution de Tuzepoito (<a href="https://tuzepoito.github.io/">son
                    blog</a>, qui contient des articles rigolos sur les GAN) (qui malheureusement était fausse durant
                le
                concours), était possible.<br />
                Cette solution exploite une méthode un peu plus avancée, appellée "Programmation dynamique" (je ne
                détaillerai pas le principe de la méthode dans cet article).<br />
                <br />
                Ici l'idée est d'utiliser ce qu'on appelle un tableau à somme de préfixes.<br />
                Ce genre de tableau stocke tout simplement, pour chaque indice i, la somme des éléments d'un tableau
                dont l'index est inférieur ou égal à i.<br />
                <br />
                Par exemple:<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/PrefixSum.png" />
                </div> <br />

                avec <code>[1,2,3,3...]</code> le tableau d'entrée, et <code>[1,3,6,9...]</code> le tableau de somme de
                préfixes construit.
                <br /><br />
                L'intérêt de ce tableau est qu'il se calcule très facilement (une simple passe linéaire), et qu'à
                partir
                de celui-ci, on peut calculer la somme de n'importe quel intervalle en temps constant.<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/Intervalles.png" />
                </div> <br />

                On peut étendre cette idée à une grille 2D de la façon suivante:<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/2DGrid.png" />
                </div> <br />
                La complexité sera ici <code>O(N*M)</code> pour initialiser le tableau 2D.<br />
                <br />
                Si on ajoute une troisième dimension <code>COULEUR</code> à ce tableau 2D, on peut calculer la somme du
                nombre de
                pixels d'une certaine couleur pour chaque rectangle de la grille.<br />
                <br />
                L'initialisation de la structure se fera en <code>O(N*M*|COULEUR|)</code> (vu qu'on réalisera simplement
                la même
                chose que pour la grille 2D, mais pour chaque couleur).<br />
                Ensuite, il suffit de parcourir la grille, et pour chaque case d'une couleur donnée, vérifier les
                sommes
                de 5 rectangles en temps constant, et ce pour les deux types de rectangles possibles, pour
                déterminer si
                on est bien en présence d'une forme de type rectangle 2x4 / 4x2.<br />
                <br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/SchemasPixels.png" />
                </div>
                <br />


                <h2 id="exo5"> Exercice 5 </h2>

                <h3 id="exo5Statement"> Enoncé </h3>

                Le dernier problème n'était pas trivial, mais était relativement classique pour les habitués de ce genre
                de concours.<br />

                Nous avions en entrées:

                <ul>
                    <li> Un tableau de 4 valeurs entières (correspondant aux <b>valeurs initiales des 4 registres</b>)
                    </li>
                    <li> Un tableau de 4 valeurs entières (correspondant aux <b>valeurs cibles des 4 registres</b>)</li>
                    <li> Une <b>liste d'instructions</b> de 3 types différents:
                        <ul>
                            <li> <code>ADD A B C</code>, qui avait pour effet d'additionner les registres <code>A</code>
                                et <code>B</code>, en mettant le
                                résultat dans le registre <code>C</code> </li>
                            <li> <code>MOV A B</code>, qui affectait la valeur du registre <code>B</code> au registre
                                <code>A</code>, puis affectait 0 au
                                registre <code>A</code> </li>
                            <li> <code>CPY A B</code>, même principe que pour le <code>MOV</code>, mais la valeur du
                                registre <code>A</code> n'est pas modifiée
                            </li>
                        </ul>

                        A noter qu'un registre pouvait être présent plusieurs fois pour une instruction (par exemple
                        <code>ADD
                        A A B => registres[A] = registres[A] + registres[B]</code>)
                    </li>
                </ul>

                L'objectif était de <b>trouver un ensemble d'instructions à supprimer</b>, de telle sorte que si l'on
                exécute
                le nouveau programme créé de manière séquentielle en
                respectant l'ordre donné par les entrées et en partant des registres initiaux, <b>on obtienne en fin
                    d'exécution les registres cibles</b>.
                <br /><br />
                Par exemple, si l'on a l'entrée

                <pre class="line-numbers language-python"><code >1 2 3 4
1 2 7 7
4
ADD A B C
ADD C D C
MOV C D
CPY C D</code></pre>

                si l'on supprime la première et troisième instruction, on obtient

                <pre class="line-numbers language-python"><code >ADD C D C
CPY C D</code></pre>

                ce qui donne comme exécution

                <pre class="line-numbers language-python"><code >1 2 3 4 # etat initial
1 2 7 4 # ADD C D C
1 2 7 7 # CPY C D</code></pre>

                qui est donc une solution au problème.

                <br /><br />
                <h3 id="exo5Solution"> Solution </h3>
                <br />
                Quand je suis arrivé à ce problème, j'avais été devancé pendant tout le long du concours par au moins
                une personne. En arrivant à ce dernier problème, j'étais deuxième,
                avec 90 secondes de retard (de souvenir).
                <br />
                A mes yeux, mon seul espoir de pouvoir dépasser le coquin premier, c'était d'avoir un dernier problème
                plutôt compliqué, et d'avoir très rapidement une bonne intuition que l'autre
                n'aurait pas eu (ou pas immédiatement).

                Malheureusement, en lisant l'énoncé, je compris que l'on n'était pas dans cette situation.<br />

                Nous allons comprendre ensemble pourquoi.
                <br /><br />
                Ici encore, nous allons appliquer à nouveau le premier réflexe à avoir dans la majorité des cas:
                <ul>
                    <li> Quelles sont les contraintes? </li>
                    <li> Qu'est ce que cela nous permet de faire? </li>
                </ul>

                Ici, aucune contrainte sur les valeurs des registres, à part qu'elles sont entières. On va supposer que
                ces valeurs peuvent être stockées dans des int.
                <br />
                Par contre, on a une contrainte très restrictive : Il y <b>au maximum 20 instructions</b> dans le
                programme donné en entrée.
                <br />
                Voyons voir si on peut l'utiliser à notre avantage...
                <br /><br />
                Lorsque l'on teste toutes les possibilités de programme, on peut représenter cet espace d'exploration
                sous la forme d'un arbre:<br />
                Le noeud initial correspond à l'état des registres avant exécution du programme, et les feuilles l'état
                des registres
                après l'exécution d'une version de notre programme.
                <br /><br />
                Si pour chaque noeud (sauf feuilles) à une <b>profondeur d</b>, on associe <b>deux enfants
                    Gauche et
                    Droite</b> (je ne vous conseille pas de choisir ces prénoms pour votre propre descendance,
                cela pourrait créer des malentendus lors de débats politiques), on pourrait associer à l'arc qui va vers
                <b>Gauche</b> le fait de ne <b> PAS </b> exécuter l'instruction d'indice <code>d</code>,
                et à l'arc qui va vers <b>Droite</b> le fait d'exécuter l'instruction d'indice <code>d</code>.
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/Dfs.png" />
                </div> <br />
                Etant donné que pour chaque noeud on a à chaque fois 2 possibilités, le nombre de noeuds à chaque
                profondeur est égal à <code> 2 ^ d</code>.
                On a donc <code> 2 ^ N</code> états finaux possibles, et
                <code>2 ^ N + 2 ^ (N - 1) .... + 2 ^ 0</code> noeuds au total dans notre graphe, soit
                <code> 2 ^ (N+1) - 1</code>.<br />

                Or, <code> 2^(21) - 1 ~=  2* 10 ^ 6</code>.<br /> On a donc la possibilité de faire ce qu'on appelle un
                <b>bruteforce</b>, c'est à dire essayer toutes les possibilités en
                parcourant cet arbre, méthode très simple à implémenter, et qui donc selon moi allait être codée
                très
                rapidement par la personne qui me devançait.
                <br /><br />
                Personnellement j'ai utilisé une méthode assez proche:<br />
                Plutôt que d'avoir un arbre à parcourir, on peut modéliser les différentes possibilités avec des
                tableaux de booléens.<br /><br />
                Par exemple, pour un programme avec 3 instructions,
                <pre class="line-numbers language-python"><code >[true, true, true]</code></pre>
                signifierait que l'on garde toutes les instructions, et
                <pre class="line-numbers language-python"><code >[false, false, false]</code></pre>
                serait le cas contraire, où l'on ne prendrait aucune instruction.
                <br /><br />
                Si l'on remplace "true" par 1, et "false" par 0, on peut transformer ces tableaux en masques
                binaires:
                <pre class="line-numbers language-python"><code >(000) en base 2 = (0) en base 10</code></pre>
                <pre class="line-numbers language-python"><code >(111) en base 2 = (7) en base 10</code></pre>
                <br />
                Essayer toutes les possibilités revient donc à choisir <b>tous les masques binaires</b> entre
                <code>(0....0)</code> et
                <code>(1....1)</code> (soit entre <code>0</code> et <code>2^(N)-1</code>).
                <br />
                Puis, pour chacune des possibilité, simuler l'exécution du programme, et vérifier à la fin de
                l'exécution si oui ou non, on obtient les registres cibles.
                <br /><br />
                Les avantages:
                <ul>
                    <li> On <b>évite les appels récursifs</b>, ces derniers étant coûteux avec l'utilisation de la
                        stack (et
                        limités par défaut dans le cas de Python) </li>
                    <li> C'est... plus rapide à coder? Débattez-en dans les commentaires </li>
                </ul>
                <br />
                Les inconvénients:
                <ul>
                    <li> <b>Moins intuitif</b> (l'idée d'arbre est une représentation avec laquelle on a l'habitude
                        de jongler,
                        par exemple pour les jeux (si je sloubi de 1, il a 2 possibilités
                        de croc sloubi ou sloubi kamoulox, mais si j'inverse le tour, et que je casse le debreak des
                        3,
                        il est forcé à caqueter, et j'le baise au tour d'après))
                    </li>
                    <li>
                        Quasi négligeable, et le récursif pénalise bien plus: La complexité est un peu moins bonne
                        (on
                        perd le backtracking): on passe de ~= 2^(N+1) opérations à (2^N)*(N),
                        vu qu'on va itérer de 0 à N -1 pour vérifier si chaque instruction fait partie du masque
                        binaire.
                    </li>
                </ul>

                <h3 id="exo5Impl"> Implémentation </h3>
                <p>
                    <button type="button" class="btn btn-outline-primary" (click)="isCollapsed3 = !isCollapsed3"
                        [attr.aria-expanded]="!isCollapsed3" aria-controls="collapseExample">
                        Afficher / Réduire le code
                    </button>
                </p>
                <div id="collapseExample" [ngbCollapse]="isCollapsed3">
                    <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "exercise.hpp"

ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}}{{'}'}}

// Fonction utilitaire qui nous transforme par exemple "ADD A B C" en {{'{'}}"ADD","A","B","C"
vector&lt;string&gt; split(string s) {{'{'}}
    s += " ";
    string current = "";
    vector&lt;string&gt; res;
    for(int c=0;c&lt;s.size();c++){{'{'}}
        if(s[c] == ' ') {{'{'}}
            if(current.size()) res.push_back(current);
            current = "";
        {{'}'}} else {{'{'}}
            current += s[c];
        {{'}'}}
    {{'}'}}
    return res;
{{'}'}}


void ContestExerciseImpl::main() {{'{'}}
    int nombreInstructions;
    cin&gt;&gt;nombreInstructions;
    
    vector&lt;int&gt; registresInitiaux(4);
    vector&lt;int&gt; registresCibles(4);
    
    vector&lt;vector&lt;string&gt; &gt; instructions(nombreInstructions);
    
    for(int c=0;c&lt;4;c++) cin&gt;&gt;registresInitiaux[c];
    cin.ignore();
    for(int c=0;c&lt;nombreInstructions;c++) {{'{'}}
        string line;
        getline(cin,line);
        instructions[c] = split(line);
    {{'}'}}
    
    for(int c=0;c&lt;4;c++) cin&gt;&gt;registresCibles[c];
    
    // On itère sur tous les masks entre 0 et 2^N-1
    for(int mask = 0; mask &lt; (1&lt;&lt;nombreInstructions); mask++) {{'{'}}
        vector&lt;int&gt; registresExecution(4);
        copy(registresInitiaux.begin(),registresInitiaux.end(),registresExecution.begin());
        for(int i = 0; i &lt; nombreInstructions; i++) {{'{'}}
            // Si le ième bit est à 1, on prend l'instruction
            if((1&lt;&lt;i) & mask) {{'{'}}
                vector&lt;string&gt; words = instructions[i];
                
                if(words[0] == "ADD") {{'{'}}
                    int r1 = words[1][0] - 'A';
                    int r2 = words[2][0] - 'A';
                    int r3 = words[3][0] - 'A';
                    registresExecution[r3] = registresExecution[r1]+registresExecution[r2];
                {{'}'}} else if (words[0] == "MOV") {{'{'}}
                    int r1 = words[1][0] - 'A';
                    int r2 = words[2][0] - 'A';
                    registresExecution[r2] = registresExecution[r1];
                    registresExecution[r1] = 0;
                {{'}'}} else if (words[0] == "CPY") {{'{'}}
                    int r1 = words[1][0] - 'A';
                    int r2 = words[2][0] - 'A';
                    registresExecution[r2] = registresExecution[r1];
                {{'}'}}
            {{'}'}}
        {{'}'}}
        bool valide = true;
        // On compare les registres obtenus avec les registres cibles
        for(int rIdx = 0; rIdx &lt; 4; rIdx ++) {{'{'}}
            if(registresExecution[rIdx] != registresCibles[rIdx]) {{'{'}}
                valide = false;
                break;
            {{'}'}}
        {{'}'}}
        if(valide) {{'{'}}
            for(int i = 0; i &lt; nombreInstructions; i++) {{'{'}}
                // On affiche uniquement les identifiants des instructions supprimées (bit à 0)
                if((1&lt;&lt;i) & mask) continue;
                cout&lt;&lt;(i+1)&lt;&lt;" ";
            {{'}'}}
            return;
        {{'}'}}
    {{'}'}}
{{'}'}}
               </code></pre>
                </div>

                <h3 id="exo5SolutionMemo"> La solution du second (déso) </h3>

                Alors avec tout ça, par quel miracle ais-je terminé premier?<br />
                Malheureusement, Nagrarok qui avait été plus rapide jusqu'à ce dernier exercice, a fait une petite
                erreur d'étourderie lors de l'évaluation de la complexité.<br />
                <code>(2^N)*(N)</code> passait largement, mais avec un peu de précipitation, le second avait pensé
                que
                ce n'était
                pas le cas.<br />

                Mais ça lui a permis de développer une solution intéressante, et d'étoffer cet article en évoquant
                sa
                méthode.
                <br /> <br />

                Sa solution se base sur une méthode que l'on a déjà vu précédemment, qui consistait à vérifier si
                l'on
                pouvait <b>éviter de calculer plusieurs fois la même chose</b>.<br />
                En effet, comme pour beaucoup de jeux (échecs, dames ...), on peut obtenir <b>exactement le même
                    état</b>,
                le
                même plateau, mais <b>avec un enchaînement d'opérations différents</b>.<br /><br />

                Ici, si l'on reprend l'arbre d'exploration de tout à l'heure, un état correspond à
                <ul>
                    <li> Une profondeur (quelle instruction sommes-nous en train de traiter)</li>
                    <li> Des valeurs de registres </li>
                </ul>

                Si deux noeuds on est les mêmes valeurs de registres, et que l'on est en train d'essayer les deux
                possibilités (utiliser ou non l'instruction <code>i</code>), on va avoir un sous-arbre d'exploration
                identique.<br />
                Nous
                n'avons donc pas raison d'explorer à nouveau.<br /><br />
                <div style="text-align:center;">
                    <img style="width:500px" src="assets/img/DFSMemo.png" />
                </div> <br />
                L'idée est donc toute bête à partir du moment où l'on se rend compte de ça:<br />
                Il suffit d'associer cet état à une <b>clé</b> (par exemple un tuple de 5 entiers, qui contiendra
                les 4 valeurs
                de registres et la profondeur), et d'enregistrer pour ces clés formées le fait d'avoir déjà exploré
                le
                sous-arbre constitué des descendants de ce noeud.<br /><br />

                That's it. De la même façon que pour l'exercice 3, on peut utiliser la structure C++ map qui aura la
                forme suivante :<br />
                <code>map&lt;tuple&lt;int,int,int,int,int&gt;,bool&gt; dejaExplore</code>.
                <br /><br />
                Maintenant, penchons-nous sur l'analyse du gain de cet algorithme.<br />
                Nous savons que cela nous permet d'élaguer l'arbre d'exploration, en évitant d'explorer deux
                "branches
                identiques". Mais qu'en est-il du pire cas?<br /><br />

                Une <b>méthode d'analyse pour les algorithmes à base de mémoïsation</b>, qui donne dans beaucoup de cas
                une bonne estimation de complexité, est de se baser sur le <b>nombre d'états uniques possibles</b> que
                l'on
                peut avoir
                au niveau de l'arbre.<br />
                En l'occurence, n'ayant aucune contraintes sur les valeurs de registres, on ne peut pas analyser de
                manière fine l'étendue de l'espace généré par les combinaisons d'instructions. Par contre le nombre
                d'instructions est limité à <code>20</code>.
                <br /><br />
                Donc une limite haute du nombre d'état serait de l'ordre de <code>|r1|*|r2|*|r3|*|r4|*20</code>,
                avec
                <code>|r1|</code> la taille
                du domaine dans lequel le registre r1 prend des valeurs (taille immense pour le cas du type "int").
                <br /><br />
                Pour chaque état, on fait une simple copie des registres (4 valeurs, opération que l'on pourrait
                d'ailleurs encore plus optimiser), on peut donc considérer que la complexité de cette fonction
                recursive
                se résume simplement à prendre:<br />
                <code>min(nombreEtatsUniques,(2^(N+1)-1))</code>
                vu que notre arbre binaire ne peut pas avoir plus de <code>(2^(N+1)-1)</code> noeuds explorés au
                total.<br /><br />


                Ce gain peut sembler très faible, mais il faut bien saisir que c'est d'une part une <b>limite haute</b>,
                et
                d'autre part qu'elle est utilisée pour qualifier le <b>pire cas possible</b>.<br />
                En pratique, on intuite que l'espace est bien plus restreint: les opérations qui nous sont donnés ne
                permettant pas de partir d'un état avec des valeurs très faibles (<code>(1,1,1,1)</code> par
                exemple)
                pour arriver à
                un état diamétralement
                opposé (<code>(1e8,1e8,1e8,1e8)</code>) en quelques opérations. <br />Une <b>progression
                    décroissante</b> est
                également
                <b>impossible</b>, à part pour atteindre des valeurs nulles (nous n'avons que <code>ADD</code>, pas
                de
                <code>SUB</code>. Seul <code>MOVE</code>
                permet
                de diminuer un registre vers 0).<br />
                Avec quelques exemples, on se rend compte qu'il peut
                y avoir beaucoup d'intersections au niveau
                des états calculés (notamment dans le cas d'un grand nombre d'instructions <code>"MOV"</code> ou
                <code>"CPY"</code>).

                <h3 id="exo5ImplMemo"> Seconde implémentation (avec mémoïsation) </h3>
                <p>
                    <button type="button" class="btn btn-outline-primary" (click)="isCollapsed4 = !isCollapsed4"
                        [attr.aria-expanded]="!isCollapsed4" aria-controls="collapseExample">
                        Afficher / Réduire le code
                    </button>
                </p>
                <div id="collapseExample" [ngbCollapse]="isCollapsed4">
                    <pre class="line-numbers language-cpp"><code >#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include "exercise.hpp"

ContestExerciseImpl::ContestExerciseImpl() : Exercise() {{'{'}}{{'}'}}

// Fonction utilitaire qui nous transforme par exemple "ADD A B C" en {{'{'}}"ADD","A","B","C"{{'}'}}
vector&lt;string&gt; split(string s) {{'{'}}
    s += " ";
    string current = "";
    vector&lt;string&gt; res;
    for(int c=0;c&lt;s.size();c++){{'{'}}
        if(s[c] == ' ') {{'{'}}
            if(current.size()) res.push_back(current);
            current = "";
        {{'}'}} else {{'{'}}
            current += s[c];
        {{'}'}}
    {{'}'}}
    return res;
{{'}'}}

vector&lt;int&gt; registresCibles(4);
vector&lt;vector&lt;string&gt; &gt; instructions;

map&lt;tuple&lt;int,int,int,int,int&gt;,bool&gt; alreadyExplore;
bool recursion(int indice, vector&lt;int&gt; &registres, int currentMask) {{'{'}}
    
    tuple&lt;int,int,int,int,int&gt; signature = make_tuple(indice,registres[0],registres[1],registres[2],registres[3]);
    if(alreadyExplore.find(signature) != alreadyExplore.end()) {{'{'}}
        return false;
    {{'}'}}
    
    // Si on a dépassé la dernière instruction, on vérifie si on a le bon état
    if(indice &gt;= instructions.size()) {{'{'}}
        for(int i=0;i&lt;4;i++) {{'{'}}
            if(registres[i] != registresCibles[i]) return false;
        {{'}'}}
        // On est content, on affiche les instructions supprimées
        for(int i = 0; i &lt; instructions.size(); i++) {{'{'}}
            if((1&lt;&lt;i) & currentMask) continue;
            cout&lt;&lt;(i+1)&lt;&lt;" ";
        {{'}'}}
        return true;
    {{'}'}}
    
    
    // Cas où l'on ignore l'instruction
    if(recursion(indice+1,registres,currentMask)){{'{'}}
        return true;
    {{'}'}}
    // Cas où l'on exécute l'instruction
    vector&lt;string&gt; words = instructions[indice];
    vector&lt;int&gt; registresCopy(4);
    copy(registres.begin(),registres.end(),registresCopy.begin());
    if(words[0] == "ADD") {{'{'}}
        int r1 = words[1][0] - 'A';
        int r2 = words[2][0] - 'A';
        int r3 = words[3][0] - 'A';
        registres[r3] = registres[r1]+registres[r2];
    {{'}'}} else if (words[0] == "MOV") {{'{'}}
        int r1 = words[1][0] - 'A';
        int r2 = words[2][0] - 'A';
        registres[r2] = registres[r1];
        registres[r1] = 0;
    {{'}'}} else if (words[0] == "CPY") {{'{'}}
        int r1 = words[1][0] - 'A';
        int r2 = words[2][0] - 'A';
        registres[r2] = registres[r1];
    {{'}'}}
    if(recursion(indice+1,registres,currentMask | (1&lt;&lt;indice))){{'{'}}
        return true;
    {{'}'}}
    
    // On remet nos registres dans le même état qu'avant application de l'instruction pour "ne pas polluer notre arbre récursif"
    // (cf backtracking)
    copy(registresCopy.begin(),registresCopy.end(),registres.begin());
    
    // On peut ignorer la mise à jour du mémo dans le cas d'un retour "true"
    // étant donné qu'un retour nous fera sortir de tous les appels récursifs directement
    // dû aux conditions des lignes 49 et 71
    alreadyExplore[signature] = true;
    return false;
{{'}'}}


void ContestExerciseImpl::main() {{'{'}}
    int nombreInstructions;
    cin&gt;&gt;nombreInstructions;
    registresCibles.resize(4);
    vector&lt;int&gt; registresInitiaux(4);
    instructions.resize(nombreInstructions);
    
    for(int c=0;c&lt;4;c++) cin&gt;&gt;registresInitiaux[c];
    cin.ignore();
    for(int c=0;c&lt;nombreInstructions;c++) {{'{'}}
            string line;
            getline(cin,line);
            instructions[c] = split(line);
    {{'}'}}
    
    for(int c=0;c&lt;4;c++) cin&gt;&gt;registresCibles[c];
    
    recursion(0,registresInitiaux,0);
{{'}'}}
               </code></pre>

                </div>
            </div>
        </div>
    </div>
</section>